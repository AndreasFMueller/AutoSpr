/*
 * mkthemaidx.cpp -- program to sort the thema index
 *
 * (c) 2017 Prof Dr Andreas MÃ¼ller, Hochschule Rapperswil
 */
#include <iostream>
#include <fstream>
#include <set>
#include <string>
#include <cstdlib>
#include <unistd.h>
#include <stdexcept>
#include <locale>

static bool	debug = false;

/**
 * class representing a thema entry
 */
class entry {
	int		_chapter;
	int		_problem;
	std::string	_thema;
	std::string	_pretty;
	std::string	_label;
public:
	int	chapter() const { return _chapter; }
	int	problem() const { return _problem; }
	const std::string&	label() const { return _label; }
	const std::string&	thema() const { return _thema; }
	const std::string&	pretty() const { return _pretty; }
	entry(const std::string& line) {
		std::string	s = line;
		// get the chapter number
		_chapter = std::stoi(s.substr(1, 1));
		// get the thema
		s = s.substr(4);
		size_t	offset = s.find('}');
		_thema = s.substr(0, offset);
		// get the problem
		s = s.substr(offset + 2);
		offset = s.find('}');
		_problem = std::stoi(s.substr(0, offset));
		// get the pretty printed problem number
		s = s.substr(offset + 2);
		offset = s.find('}');
		_pretty = s.substr(0, offset);
		// get the label
		s = s.substr(offset + 2);
		offset = s.find('}');
		_label = s.substr(0, offset);
		//std::cout << line << std::endl;
		//std::cout << _thema << "|" << _chapter << "|" << _problem << std::endl;
	}
	bool	operator==(const entry& other) const {
		if (_chapter != other._chapter) {
			return false;
		}
		if (_problem != other._problem) {
			return false;
		}
		if (_thema != other._thema) {
			return false;
		}
		return true;
	}
	bool	operator<(const entry& other) const {
		if (_thema > other._thema) {
			return false;
		}
		if (_thema < other._thema) {
			return true;
		}
		// _thema == other._thema
		if (_chapter > other._chapter) {
			return false;
		}
		if (_chapter < other._chapter) {
			return true;
		}
		// _thema == other._thema
		return _problem < other._problem;
	}
};

std::ostream&	operator<<(std::ostream& out, const entry& e) {
	out << e.thema() << " " << e.chapter() << " " << e.problem();
	return out;
}

typedef std::set<entry>	themaindex_t;

int	main(int argc, char *argv[]) {
	int	c;
	while (EOF != (c = getopt(argc, argv, "d")))
		switch (c) {
		case 'd':
			debug = true;
			break;
		}

	// next two parameters are the two file names
	if ((argc - optind) < 2) {
		std::cerr << "not enough arguments" << std::endl;
		return EXIT_FAILURE;
	}

	std::string	infilename = argv[optind++];
	std::string	outfilename = argv[optind++];

	if (debug) {
		std::cerr << "input file: " << infilename << std::endl;
		std::cerr << "output file: " << outfilename << std::endl;
	}

	std::ifstream	in(infilename, std::ios::binary | std::ios::in);

	themaindex_t	theindex;

	int	counter = 0;
	while (in.good()) {
		char	line[1024];
		in.getline(line, sizeof(line));
		std::string	l(line);
		try {
			entry	e(l);
			theindex.insert(e);
			counter++;
		} catch (const std::exception& x) {
		}
	}

	in.close();

	std::ofstream	out(outfilename, std::ios::binary | std::ios::out);

	out << "% don't edit this file, it was generated by ";
	out << argv[0];
	out << " from ";
	out << infilename;
	out << std::endl;

	themaindex_t::const_iterator	i;
	std::string	thema;
	for (i = theindex.begin(); i != theindex.end(); i++) {
		if (thema != i->thema()) {
			if (thema.size() != 0) {
				out << "}" << std::endl;
			}
			thema = i->thema();
			out << "\\themasection{" << thema << "}{";
		} else {
			out << ", ";
		}
		out << "\\hyperref[" << i->label() << "]{";
		out << i->chapter() << "." << i->problem();
		out << "}";
	}
	out << "}" << std::endl;
	out.close();
	
	return EXIT_SUCCESS;
}
