Nehmen sie dieselbe Modifikation, die in Aufgabe~\ref{80000001}
zu RISC-LOOP geführt hat,
an WHILE vor, was dann die Sprache RISC-WHILE ergibt. Die {\tt WHILE}-Operation
ist ähnlich wie {\tt LOOP} in RISC-LOOP auf das Register $r$ beschränkt:
\[
\text{\tt WHILE }r>0\text{ \tt DO} \dots { \tt END}
\]
Ist RISC-WHILE Turing vollständig?

\thema{WHILE}
\thema{Turing-vollständig}

\begin{loesung}
Genau so wie sich in LOOP alle Anweisungen in RISC-LOOP übersetzen
liessen, lassen sich auch in WHILE alle Anweisungen in RISC-WHILE
übersetzen. Gezeigt werden muss dies nur noch für die {\tt WHILE}-Anweisung.
Wir übersetzen als Beispiel $\text{\tt WHILE }x_3 > 0\text{ \tt DO }P \text{ \tt END}$
\begin{center}
\begin{tabular}{r<{:}l}
 1& {\tt INCR}\\
 2& {\tt INCR}\\
 3& {\tt INCR}\\
 4& $r:=x_i$\\
 5& {\tt DECR}\\
 6& {\tt DECR}\\
 7& {\tt DECR}\\
 8& {\tt WHILE }$r > 0$ { \tt DO}\\
 9& {\tt \ \ }$P$\\
10& {\tt \ \ INCR}\\
11& {\tt \ \ INCR}\\
12& {\tt \ \ INCR}\\
13& {\tt \ \ }$r:=x_i$\\
14& {\tt \ \ DECR}\\
15& {\tt \ \ DECR}\\
16& {\tt \ \ DECR}\\
17& {\tt END}
\end{tabular}
\end{center}
Natürlich ist diese Implementation nicht unbedingt effizient, offenbar werden
viel zu viele {\tt INCR} und {\tt DECR} Befehle ausgeführt. Doch kann ein
dem Compiler nachgeschalteter Optimizer aufeinanderfolgende {\tt INCR} und
{\tt DECR} eliminieren, und dafür auch die Reihenfolge von Befehlen ändern.
Zum Beispiel können Berechnungsanweisungen $r:= r\pm c$ mit {\tt INCR}
oder {\tt DECR} vertauscht werden.
\end{loesung}
