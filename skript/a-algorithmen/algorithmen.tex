\chapter{Algorithmen-Übersicht\label{skript:algorithmen}}
\lhead{Algorithmen-Übersicht}
\rhead{}
In den vergangenen Kapiteln wurde eine grosse Zahl von Algorithmen
für die verschiedensten Probleme formuliert. Hier werden die wichtigsten
im Sinne einer Übersicht zusammengestellt, mit Verweisen auf die 
detaillierte Beschreibung weiter vorne im Text.
\section{Endliche Automaten und reguläre Sprachen}
\subsection{Minimalautomat}
\newtheorem*{Minimalautomat}{Minimalautomat}
\begin{Minimalautomat}
Zu jedem deterministischen endlichen Automaten $A$ finde den minimalen
Automaten $A'$.
\end{Minimalautomat}
Der Satz~\ref{satz_minimalautomat} beschreibt die Eigenschaften des
Minimalautomaten, anschliessend im Text wird der ``Kreuzchen''-Algorithmus
beschrieben, mit dem der Minimalautomat gefunden werden kann.

\newtheorem*{Automatenvergleich}{Automatenvergleich}
\begin{Automatenvergleich}
Gegeben zwei endliche Automaten $A$ und $B$ finde heraus, ob die
beiden Automaten die gleiche Sprache akzeptieren, also $L(A)=L(B)$.
\end{Automatenvergleich}
Das Problem, ob zwei Automaten die gleiche Sprache akzeptieren,
ist mit Hilfe des Minimalautomaten (Seite \pageref{algorithmus:minimalautomat})
entscheidbar. 
Der Algorithmus wurde auch im Satz~\ref{satz:eqdea} verwendet, wo die
Entscheidbarkeit von $\textsl{EQ}_\textsl{DEA}$ gezeigt wurde.


\subsection{NEA}
\newtheorem*{NEA}{Umwandlung NEA $\to$ DEA}
\begin{NEA}
Ein nicht deterministischer endlicher Automat $A$ kann in einen 
deterministischen endlichen Automaten $B$ umgewandelt werden, der die
gleiche Sprache akzeptiert, $L(A)=L(B)$.
\end{NEA}

Der Umwandlungsalgorithmus NEA $\to$ DEA wird in
Abschnitt~\ref{regulaer:nea-dea}
auf
Seite~\pageref{regulaer:nea-dea}
beschrieben.

\subsection{Mengenoperationen}
Die Menge der reguläre Sprachen ist abgeschlossen bezüglich der
Mengenoperationen, es muss also Algorithmen geben, die die Mengenoperationen
auf Automatenebene implementieren.

\newtheorem*{RegVereinigung}{Vereinigung regulärer Sprachen}
\begin{RegVereinigung}
Zu zwei deterministischen endlichen Automaten $A$ und $B$ berechne einen
Automaten $C$ derart, dass $L(C)=L(A)\cup L(B)$.
\end{RegVereinigung}

Die Vereinigung wird in Satz~\ref{satz_union} beschrieben, sie tritt auch als
Alternative bei den regulären Operationen auf.

\newtheorem*{RegSchnitt}{Schnittemenge regulärer Sprachen}
\begin{RegSchnitt}
Zu zwei deterministischen endlichen Automaten $A$ und $B$ berechne einen
Automaten $C$ derart, dass $L(C)=L(A)\cap L(B)$.
\end{RegSchnitt}

Satz~\ref{satz_intersection} beschreibt eine Konstruktion, mit der
ein deterministischer endlicher Automat für die Schnittmenge gefunden
werden kann. Sie verwendet die Produktautomaten-Konstruktion von Seite
\pageref{reg_produktautomat}.

\newtheorem*{RegNegation}{Komplement einer regulären Sprache}
\begin{RegNegation}
Zu einem deterministischen endlichen Automaten $A$ berechne den Automaten
$B$ mit der Eigenschaft $L(B)=\overline{L(A)}$.
\end{RegNegation}

Der Algorithmus tauscht Akzeptier- und Nichtakzeptierzustände aus,
und funktioniert in dieser Form nur für deterministische endliche
Automaten (Satz~\ref{satz_regcomplement}).

\newtheorem*{RegDifferenz}{Differenz zweier regulärer Sprachen}
\begin{RegDifferenz}
Zu zwei gegebenen deterministischen endlichen Automaten $A$ und $B$ 
berechne einen deterministischen endlichen Automaten $C$ mit
$L(C)=L(A)\setminus L(B)$.
\end{RegDifferenz}

Die Mengendifferenz ist die Schnittmenge mit dem Komplement:
$L(A)\setminus L(B)=L(A)\cap\overline{L(B)}$, der Algorithmus wird im Beweis
von Satz~\ref{satz_regcomplement} dargestellt.

\subsection{Reguläre Operationen}
Reguläre Operationen können in Operationen mit nicht deterministischen
endlichen Automaten übersetzt werden.
Die Verkettung wird in Satz~\ref{satz_concat} beschrieben, die *-Operation
in Satz~\ref{satz_star}.

\newtheorem*{Alternative}{Alternative}
\begin{Alternative}Zu zwei endlichen Automaten $A$ und $B$ berechne einen
Automaten $C$, der die Alternative der beiden Sprachen akzeptiert, also
$L(C)=L(A)|L(B)=L(A)\cup L(B)$.
\end{Alternative}

\newtheorem*{Verkettung}{Verkettung}
\begin{Verkettung}
Zu zwei endlichen Automaten $A$ und $B$ berechnen einen Automaten $C$,
der die Verkettung der Sprachen von $A$ und $B$ akzeptiert: $L(C)=L(A)L(B)$.
\end{Verkettung}

\newtheorem*{Sternoperation}{Stern-Operation}
\begin{Sternoperation}
Zu einem endlichen Automaten $A$ berechne einen Automaten $B$, der die
Stern-Operation der Sprache von $A$ akzeptiert: $L(B)=L(A)^*$.
\end{Sternoperation}



\subsection{Reguläre Ausdrücke}
\newtheorem*{RegexDea}{Regulären Ausdruck in DEA umwandeln}
\begin{RegexDea} Berechne aus einem regulären Ausdruck $r$ einen 
deterministischen endlichen Automaten $A$, der die gleiche Sprache
akzeptiert, also $L(A)=L(r)$.
\end{RegexDea}

Die Umwandlung eines regulären Ausdrucks in einen endlichen Automaten
wird in Abschnitt~\ref{regulaer:regulaere-ausdruecke} beschrieben.

\newtheorem*{DeaRegex}{DEA in regulären Ausdruck umwandeln}
\begin{DeaRegex}
Zu einem deterministischen endlichen Automaten $A$ berechne einen
regulären Ausdruck $r$, der die gleiche Sprache akzeptiert,
also $L(A)=L(r)$.
\end{DeaRegex}

Die Umwandlung eines endlichen Automaten in einen äquivalenten
regulären Ausdrucks 
wird in Abschnitt~\ref{regulaer:dea-re} beschrieben.

\section{Stackautomaten und kontextfreie Grammatiken}

\subsection{Stackautomaten}
Zum Beweis der Äquivalenz von Stackautomaten und kontextfreien Grammatiken
wurden im Abschnitt~\ref{sect:aequivalenz-cfg} zwei Algorithmen beschrieben,
wie man eine kontextfreie Grammatik in einen äquivalenten Stackautomanten
umwandenl kann und umgekehrt.

\newtheorem*{CfgPDA}{Stackautomat einer Grammatik}
\begin{CfgPDA}
Zu einer kontextfreien Grammatik $G$ finde einen Stackautomaten $P$, 
der genau die von $G$ produzierte Sprache akzeptiert: $L(G)=L(P)$.
\end{CfgPDA}

\newtheorem*{PdaCfg}{Grammatik eines Stackautomaten}
\begin{PdaCfg}
Zu einem Stackautomaten $P$ findet eine kontextfreie Grammatik $G$, die
die gleiche Sprache produziert: $L(G)=L(P)$.
\end{PdaCfg}

\subsection{Chomsky-Normalform}
Die Chomsky-Normalform wird in Definition~\ref{definition:cnf} definiert.
Im Beweis von Satz~\ref{satz:cnf} wird die Umwandlung in eine äquivalente
Grammatik in Chomsky-Normalform dargestellt.

\newtheorem*{CNF}{Chomsky-Normalform einer Grammatik}
\begin{CNF}
Zu einer kontextfreien Grammatik $G$ finde eine kontextfreie Grammatik $G'$
in Chomsky-Normalform, die die gleiche Sprache akzeptiert.
\end{CNF}

\subsection{Mengenoperationen}
Nur für die Vereinigung zweier kontextfreier Sprachen haben wir einen
Algorithmus.

\newtheorem*{CfgUnion}{Grammatik einer Vereinigung}
\begin{CfgUnion}
Aus zwei kontextfreien Grammatiken $G_1$ und $G_2$ berechne
eine kontextfreie Grammatik $G$, die die
Vereinigung der von $G_1$ und $G_2$ produzierten Sprachen prodziert:
$L(G)=L(G_1)\cup L(G_2)$.
\end{CfgUnion}

\subsection{Reguläre Operationen}
Die regulären Operationen auf Grammatiken wurden in
Abschnitt~\ref{sect:cfg-regulaer} beschrieben.
Die Alternative ist in Satz~\ref{satz:cfg-union} erklärt,
die Verkettung in Satz~\ref{satz:cfg-verkettung} und die *-Operation
in Satz~\ref{satz:cfg-star}.

\newtheorem*{CfgAlternative}{Grammatik für eine Alterative}
\begin{CfgAlternative}
Zu zwei kontextfreien Grammatiken $G_1$ und $G_2$ finde eine
kontextfreie Grammatik $G$, die die
Alternative der von $G_1$ und $G_2$ produzierten Sprachen produziert:
$L(G)=L(G_1)|L(G_2)=L(G_1)\cup L(G_2)$.
\end{CfgAlternative}

\newtheorem*{CfgConcatenation}{Grammatik einer Verkettung}
\begin{CfgConcatenation}
Zu zwei kontextfreien Grammatiken $G_1$ und $G_2$ berechne eine 
kontextfreie Grammatik $G$, die die Verkettung der von $G_1$ und $G_2$
produzierten Sprachen produziert: $L(G)=L(G_1)L(G_2)$.
\end{CfgConcatenation}

\newtheorem*{CfgStar}{Grammatik für die Sternoperation}
\begin{CfgStar}
Zu einer kontextfreien Grammatik $G$ berechne eine kontextfreie Grammatik
$G'$, die die *-Operation der von $G$ produziert Sprache produziert:
$L(G')=L(G)^*$.
\end{CfgStar}

\subsection{Parser}
Stackautomaten sind nicht deterministisch und eignen sich daher nicht
dazu, ein Wort $w$ daraufhinzu zu prüfen, ob es von einer kontextfreien
Grammatik $G$ produziert werden kann: $w\in L(G)$. 
Es gibt aber einen deterministischen Algorithmus, der in
Satz~\ref{cyk-algorithm} beschrieben wird.
Dieser Algorithmus wird auch zur Entscheidung des Problems $A_\textsl{CFG}$
in Satz~\ref{satz:acfg-entscheidbar}
benötigt.

\newtheorem*{CYK}{Cocke-Younger-Kasami Algorithmus}
\begin{CYK}
Zu einer kontextfreien Grammatik $G$ in Chomsky-Nor\-mal\-form und einem
Wort $w$ berechne den Ableitungsbaum (Parse-Tree) von $w$.
\end{CYK}

%\section{Graphen}

%\section{Turingmaschinen}

