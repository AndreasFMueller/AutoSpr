%
% Turing-Vollstaendigkeit
%
% (c) 2011 Prof Dr Andreas Mueller, Hochschule Rapperswil
% $Id$
%
\chapter{Turing-Vollst"andigkeit\label{chapter-vollstaendigkeit}}
\lhead{Vollst"andigkeit}
\section{Turing-vollst"andige Programmiersprachen}
\rhead{Turing-vollst"andige Programmiersprachen}
Die Turing-Maschine liefert einen wohldefinierten Begriff der
Berechenbarkeit, der auch robust gegen"uber milden "Anderungen
der Definition einer Turing-Maschine ist.
Der Aufbau aus einem endlichen Automaten mit zus"atzlichem
Speicher und der einfache Kalk"ul mit Konfigurationen hat
sie ausserdem Beweisen vieler wichtiger Eigenschaften zug"anglich
gemacht. Die vorangegangenen Kapitel "uber Entscheidbarkeit und
Komplexit"at legen davon eindr"ucklich Zeugnis ab. Am direkten
Nutzen dieser Theorie kann jedoch immer noch ein gewisser Zweifel
bestehen, da ein moderner Entwickler seine Programme ja nicht
direkt f"ur eine Turing-Maschine schreibt, sondern nur mittelbar,
da er eine Programmiersprache verwendet, deren Code anschliessend
von einem Compiler oder Interpreter "ubersetzt und von einer realen
Maschine ausgef"uhrt wird.

Der Aufbau der realen Maschine ist sehr
nahe an einer Turing-Maschine, ein Prozessor liest und schreibt
jeweils einzelne
Speicherzellen eines mindestens f"ur praktische Zwecke unendlich
grossen Speichers und "andert bei Verarbeitung der gelesenen
Inhalte seinen eigenen Zustand. Nat"urlich ist die Menge der
Zust"ande eines modernen Prozessors sehr gross, nur schon die $n$
Register der L"ange $l$ tragen $2^{nl}$ verschiedene Zust"ande bei,
und jedes andere Zustandsbit verdoppelt die Zustandsmenge nochmals.
Trotzdem ist die Zustandsmenge endlich, und es braucht nicht viel
Fantasie, sich den Prozessor mit seinem Hauptspeicher als Turingmaschine
vorzustellen. Es gibt also kaum Zweifel, dass die Computer-Hardware
zu all dem f"ahig ist, was ihr in den letzten zwei Kapiteln an
F"ahigkeiten zugesprochen wurde.

Die einzige Einschr"ankung der F"ahigkeiten realer Computer gegen"uber
Turing-Maschinen ist
die Tatsache, dass reale Computer nur "uber einen endlichen Speicher
verf"ugen, w"ahrend eine Turing-Maschine ein undendlich langes Band
als Speicher verwenden kann. Da jedoch eine endliche Berechnung auch
nur endlich viel Speicher verwenden kann, sind alle auf einer Turing-Maschine
durchf"uhrbaren Berechnungen, die man auch tats"achlich durchf"uhren
will, auch von einer realen Computer durchf"uhrbar. F"ur praktische
Zwecke darf man also annehmen, dass die realen Computer echte Turing-Maschinen
sind.

Trotzdem ist nicht sicher, ob die Programmierung in einer "ubersetzten
oder interpretierten Sprache alle diese F"ahigkeiten auch einem
Anwendungsprogrammierer zug"anglich macht.
Letztlich "aussert sich dies auch darin, dass Computernutzer
f"ur verschiedene Problemstellung auch verschiedene Werkzeuge
verwenden. Wer tabellarische Daten summieren will, wird gerne
zu einer Spreadsheet-Software greifen, aber nicht erwarten, dass er
damit auch einen N"aherungsalgorithmus f"ur das Cliquen-Problem wird
programmieren k"onnen. Die Tabellenkalkulation definiert ein eingeschr"anktes,
an das Problem angepasstes Berechnungsmodell, welches aber
h"ochstwahrscheinlich weniger leistungsf"ahig ist als die Hardware, auf
der es l"auft. Es ist also durchaus m"oglich und je nach Anwendung auch
zweckm"assig, dass ein Anwender nicht die volle Leistung einer
Turing-Maschine zur Verf"ugung hat.

Damit stellt sich jetzt die Frage, wie man einem Berechnungsmodell und
das heisst letztlich der Sprache, in der der Berechnungsauftrag
formuliert wird, ansehen kann, ob sie gleich m"achtig ist wie eine
Turing-Maschine.

\subsection{Programmiersprachen}
Eine Programmiersprache ist zwar eine Sprache im Sinne dieses Skriptes,
f"ur den Programmierer wesentlich ist jedoch die Semantik, die bisher
nicht Bestandteil der Diskussion war. F"ur ihn ist die Tatsache wichtig,
dass die Semantik der Sprache Berechnungen beschreibt,
wie sie mit einer Turing-Maschine ausgef"uhrt werden k"onnen.

\begin{definition}
\index{Programmiersprache}
Eine Sprache $A$ heisst eine {\em Programmiersprache}, wenn es eine Abbildung
\[
c\colon A\to \Sigma^*\colon w\mapsto c(w)
\]
gibt, die einem Wort der Sprache die Beschreibung einer Turing-Maschine
zuordnet. Die Abbildung $c$ heisst {\em Compiler} f"ur die Sprache $A$.
\end{definition}
Die Forderung, dass $c(w)$ die Beschreibung einer Turing-Maschine
sein muss, ist nach obiger Diskussion nicht wesentlich.

\subsection{Interaktion}
Man beachte, dass in dieser Definition einer Programmiersprache kein Platz ist
f"ur Input oder Output w"ahrend des Programmlaufes.
Das Band der Turing-Maschine, bzw.~sein Inhalt bildet den Input, der Output
kann nach Ende der Berechnung vom Band gelesen werden.
Man k"onnte dies als Mangel dieses Modells ansehen, in der Tat ist aber
keine Erweiterung n"otig, um Interaktion abzubilden.
Interaktionen mit einem Benutzer bestehen immer aus einem Strom von
Ereignissen, die dem Benutzer zufliessen ("Anderungen des Bildschirminhaltes,
Signalt"one) oder die der Benutzer veranlasst (Bewegungen des Maus-Zeigers,
Maus-Klicks, Tastatureingaben). Alle diese Ereignisse kann man sich codiert
auf ein Band geschrieben denken, welches die Turing-Maschine bei Bedarf
liest.

Der Inhalt des Bandes einer Standard-Turing-Maschine kann w"ahrend des
Programmlaufes nur von der Turing-Maschine selbst ver"andert werden.
Da sich die Turing-Maschine aber nicht daran erinnern kann, was beim
letzten Besuch eines Feldes dort stand, ist es f"ur eine Turing-Maschine
auch durchaus akzeptabel, wenn der Inhalt eines Feldes von aussen
ge"andert wird. Nat"urlich werden damit gewisse Eigenschaften von
Turing-Maschinen m"oglicherweise ver"andert. Doch in Anbetracht der
Tatsache, dass von einer Turing-Maschine im Allgemeinen nicht einmal
entschieden werden kann, ob sie anhalten wird, ist wohl nicht mehr
viel zu verlieren.

Die Ausgaben eines Programmes sind deterministisch, und was der Benutzer
erreichen will, sowie die Ereignisse, die er einspeisen wird, sind es ebenfalls.
Man kann also im Prinzip im Voraus wissen, was ausgegeben werden wird
und welche Ereignisse ein Benutzer ausl"osen wird. Schreibt man diese
Vorg"angig auf das Band, so wie man es auch beim automatisierten Testen
eines Userinterfaces tut, entsteht aus dem interaktiven Programm eines,
welches ohne Zutun des Benutzers zur Laufzeit funktionieren kann.

\subsection{Die universelle Turing-Maschine}
\index{Turing, Alan}
\index{Turing-Maschine!universelle}
In seinem Paper von 1936 hat Alan Turing gezeigt, dass man eine
Turing-Maschine definieren kann,
der man die Beschreibung
$\langle M,w\rangle$
einer Turing-Maschine $M$ und eines Wortes $w$
und die $M$ auf dem Input-Wort $w$ simuliert.
Diese spezielle Turing-Maschine ist also leistungsf"ahig genug, jede
beliebige andere Turing-Maschine zu simulieren. Sie heisst die {\em universelle
Turing-Maschine}.

Die universelle Turing-Maschine kann die Entscheidung vereinfachen,
ob eine Funktion Turing-berechenbar ist. Statt eine Turing-Maschine
zu beschreiben, die die Funktion berechnet, reicht es, ein Programm
in der Programmiersprache $A$ zu beschreiben, das Programm mit dem
Compiler $c$ zu "ubersetzen, und die Beschreibung mit der universellen
Turing-Maschine auszuf"uhren.

\index{Church-Turing-Hypothese}
Die Church-Turing-Hypothese besagt, dass sich alles, was man berechnen
kann, auch mit einer Turing-Maschine berechnen l"asst. Die universelle
Turing-Maschine zeigt, dass jede berechenbare Funktion von der
universellen Turing-Maschine berechnet werden kann.
Etwas leistungsf"ahigeres als eine Turing-Maschine gibt es nicht.

\subsection{Turing-Vollst"andigkeit}
Jede Funktion, die in der Programmiersprache $A$ implementiert werden
kann, ist Turing-berechenbar.
Der Compiler kann
aber durchaus F"ahigkeiten unzug"anglich machen, die Programmiersprache
$A$ kann dann gewisse Berechnungen, die mit einer Turing-Maschine
m"oglich w"aren, nicht formulieren. Besonderes interessant sind daher
die Sprachen, bei denen ein solcher Verlust nicht eintritt.

\begin{definition}
\index{Turing-vollst\"andig}
Eine Programmiersprache heisst Turing-vollst"andig, wenn sich jede
berechenbare Abbildung in dieser Sprache formulieren l"asst.
Zu jeder berechenbaren Abbildung $f\colon\Sigma^*\to \Sigma^*$ gibt
es also ein Programm $w$ so, dass $c(w)$ die Funktion $f$ berechnet.
\end{definition}

Zu einer berechenbaren Abbildung gibt es eine Turing-Maschine, die
sie berechnet, es w"urde also gen"ugen, wenn man diese Turing-Maschine
von einem in der Sprache $A$ geschriebenen Turing-Maschinen-Simulator
ausf"uhren lassen k"onnte. Dieser Begriff muss noch etwas klarer gefasst
werden:

\begin{definition}
\index{Turing-Maschinen-Simulator}
Ein Turing-Maschinen-Simulator ist eine Turing-Maschine $S$, die als Input
die Beschreibung $\langle M,w\rangle$ einer Turing-Maschine $M$ und eines
Input-Wortes f"ur $M$ erh"alt, und die Berechnung durchf"uhrt, die $M$ auf $w$
ausf"uhren w"urde.
Ein Turing-Maschinen-Simulator in der Programmiersprache $A$ ist
ein Wort $s\in A$ so, dass $c(s)$ ein Turing-Maschinen-Simulator ist.
\end{definition}

Damit erhalten wir ein Kriterium f"ur Turing-Vollst"andigkeit:

\begin{satz}
\label{turingvollstaendigkeitskriterium}
Eine Programmiersprache $A$ ist Turing-vollst"andig, genau dann
wenn es einen Turing-Maschinen-Simulator in $A$ gibt.
\end{satz}


\subsection{Beispiele}
Die "ublichen Programmiersprachen sind alle Turing-vollst"andig, denn es
ist eine einfache Programmier"ubung, eines Turing-Maschinen-Simulator
in einer dieser Sprachen zu schreiben. In einigen Programmiersprachen
ist dies jedoch schwieriger als in anderen.

\subsubsection{Javascript}
\index{Javascript}
Fabrice Bellard hat 2011 einen PC-Emulator in Javascript geschrieben, der
leistungsf"ahig genug ist, Linux zu booten. Auf seiner Website
\url{http://bellard.org/jslinux/} kann man den Emulator im eigenen Browser
starten. Das gebootete Linux enth"alt auch einen C-Compiler. Da C
Turing-vollst"andig ist, gibt es einen Turing-Maschinen-Simulator in
C, den man auch auf dieses Linux bringen und mit dem C-Compiler
kompilieren kann. Somit gibt es einen Turing-Maschinen-Simulator in
Javascript, Javascript ist Turing-vollst"andig.

\subsubsection{XSLT}
\index{XSLT}
XSLT ist eine XML-basierte Sprache, die Transformationen von XML-Dokumenten
zu beschreiben erlaubt. XSLT ist jedoch leistungsf"ahig, eine Turing-Maschine
zu simulieren. Bob Lyons hat auf seiner Website
\url{http://www.unidex.com/turing/utm.htm} ein XSL-Stylesheet publiziert,
welches einen Simulator implementiert. Als Input verlangt es
ein
XML-Dokument, welches die Beschreibung der Turing-Maschine in einem
zu diesem Zweck definierten XML-Format namens Turing Machine Markup
Language (TMML) enth"alt. TMML definiert XML-Elemente, die das Alphabet
(\verb+<symbols>+),
die Zustandsmenge $Q$ (\verb+<state>...</state>+)
und die "Ubergangsfunktion $\delta$ in \verb+<mapping>+-Elementen
der Form
\begin{verbatim}
<mapping>
    <from current-state="moveRight1" current-symbol=" " />
    <to next-state="check1" next-symbol=" " movement="left" />
</mapping>
\end{verbatim}
beschreiben. Der initiale Bandinhalt wird als Parameter \verb+tape+
auf der Kommandozeile "ubergeben.
Das Stylesheet wandelt das TMML Dokument in eine ausf"uhrliche
Berechnungsgeschichte um, aus der auch der Bandinhalt am Ende der Berechnung
abzulesen ist. Es beweist somit, dass XSLT einen Turing-Maschinen-Simulator
hat, also Turing-vollst"anddig ist.

\subsubsection{\LaTeX}
\index{LaTeX@\LaTeX}
\index{Knuth, Don}
Don Knuth, der Autor von \TeX, hat sich lange davor gedr"uckt, seiner
Schriftsatz-Sprache auch eine Turing-vollst"andige Programmiersprache
zu spendieren. Schliesslich kam er nicht mehr darum herum, und wurde
von Guy Steeles richtigegehend dazu gedr"angt, wie er in
\url{http://maps.aanhet.net/maps/pdf/16\_15.pdf}
gesteht.

Dass \TeX Turing-vollst"andig ist beweist ein Satz von \LaTeX-Macros, den
man auf
\url{http://en.literateprograms.org/Turing\_machine\_simulator\_(LaTeX)}
finden kann.
Um ihn zu verwenden, formuliert man die Beschreibung
von Turing-Maschine und initialiem Bandinhalt als eine Menge von
\LaTeX-Makros. Ebenso ruft man den Makro \verb+\RunTuringMachine+ auf,
der die Turing-Machine simuliert und die Berechnungsgeschichte im
\TeX-"ublichen perfekten Schriftsatz ausgibt.



\section{Kontrollstrukturen und Turing-Vollst"andigkeit}
\rhead{Kontrollstrukturen}
Das Turing-Vollstandigkeits-Kriterium von Satz
\ref{turingvollstaendigkeitskriterium} verlangt, dass man einen
Turing-Maschinen-Simulator in der gew"ahlten Sprachen schreiben muss.
Dies ist in jedem Fall eine nicht triviale Aufgabe.
Daher w"are es n"utzlich Kriterien zu erhalten, welche einfacher
anzuwenden sind. Einen wesentlichen Einfluss auf die M"oglichkeiten,
was sich mit einer Programmiersprache ausdr"ucken lassen, haben die
Kontrollstrukturen.

\subsection{LOOP}
\index{LOOP}
Die Programmiersprache
LOOP\footnote{Die in diesem Abschnitt beschriebene
LOOP Sprache darf nicht verwechselt werden mit dem gleichnamigen
Projekt einer objektorientierten parallelen Sprache seit
2001 auf Sourceforge.}
hat als einzige Kontrollstruktur die
Iteration eines Anweisungs-Blocks mit einer festen, innerhalb des
Blocks nicht ver"anderbaren Anzahl von Durchl"aufen.

\subsubsection{Syntax}
LOOP hat folgende Syntax-Elemente
\begin{compactitem}
\item Variablen $x_0$, $x_1$, $x_2$,\dots
\item Konstanten: {\tt 0}, {\tt 1}, {\tt 2}, \dots
\item Zuweisung: {\tt :=}
\item Trennung von Anweisungen: {\tt ;}
\item Operatoren: {\tt +} und {\tt -}
\item Schl"usselw"orter: {\tt LOOP}, {\tt DO}, {\tt END}
\end{compactitem}
Die einzige M"oglichkeit, den Wert einer Variablen zu "andern ist die
Zuweisung.  Diese ist entweder die Zuweisung einer Konstante als
Wert einer Variable:
\begin{algorithmic}
\STATE $x_i${\tt :=} $c$
\end{algorithmic}
oder eine Berechnung mit den beiden vorhandenen Operatoren
\begin{algorithmic}
\STATE $x_i$ {\tt :=} $x_j$ {\tt +} $c$
\STATE $x_i$ {\tt :=} $x_j$ {\tt -} $c$
\end{algorithmic}
Dabei ist das Resultat der Subtraktion als $0$ definiert, wenn
der Minuend kleiner ist als der Subtrahend.

Programme werden daraus wie folgt aufgebaut:
\begin{itemize}
\item Das leere Programm $\varepsilon$ ist eine LOOP-Programm,
w"ahrend der Ausf"uhrung tut es nichts.
\item Wertzuweisungen sind LOOP-Programme
\item Sind $P_1$ und $P_2$ LOOP-Programme, dann auch
$P_1{\tt ;}P_2$. Um dieses Programm auszuf"uhren wird zuerst $P_1$
ausgef"uhrt und anschliessend $P_2$.
\item Ist $P$ ein LOOP-Programm, dann ist auch
\begin{algorithmic}
\STATE {\tt LOOP} $x_i$ {\tt DO} $P$ {\tt END}
\end{algorithmic}
ein LOOP-Programm. Die Ausf"uhrung wiederholt $P$ so oft, wie der
Wert der Variable $x_i$  zu Beginn angibt.
\end{itemize}
Durch Setzen der Variablen $x_i$ kann einem LOOP-Progamm Input "ubergeben
werden.
Ein LOOP-Programm definiert also eine Abbildung $\mathbb N^k\to\mathbb N$,
wobei $k$ die Anzahl der Variablen ist, in denen Input zu "ubergeben ist.

\subsubsection{Beispiel: Summer zweier Variablen}
LOOP kann nur jeweils eine Konstante hinzuaddieren, das gen"ugt aber
bereits, um auch die Summe zweier Variablen zu berechnen. Der folgende
Code berechnet die Summe von $x_1$ und $x_2$ und legt das Resultat in
$x_0$ ab:
\begin{algorithmic}
\STATE $x_0$ {\tt := } $x_1$
\STATE {\tt LOOP} $x_2$ {\tt DO}
\STATE{\tt \ \ \ \ }$x_0:=x_0$ {\tt +} $1$
\STATE{\tt END}
\end{algorithmic}

\subsubsection{Beispiel: Produkt zweier Variablen}
\index{Multiplikation}
Die Sprache LOOP ist offenbar relativ primitiv, trotzdem
ist sie leistungsf"ahig genug, um die Multiplikation von zwei
Zahlen, die in den Variablen $x_1$ und $x_2$ "ubergeben werden,
zu berechnen:

\begin{algorithmic}
\STATE $x_0$ {\tt := } $0$
\STATE {\tt LOOP} $x_1$ {\tt DO}
\STATE{\tt \ \ \ \ LOOP} $x_2$ {\tt DO}
\STATE{\tt \ \ \ \ \ \ \ \ }$x_0:=x_0$ {\tt +} $1$
\STATE{\tt \ \ \ \ END}
\STATE{\tt END}
\end{algorithmic}

\subsubsection{IF-Anweisung}
In LOOP fehlt eine IF-Anweisung, auf die die wenigsten Programmiersprachen
verzichten. Es ist jedoch leicht, eine solche in LOOP nachzubilden.
Eine Anweisung
\begin{algorithmic}
\STATE {\tt IF} $x = 0$ {\tt THEN } $P$ {\tt END}
\end{algorithmic}
kann unter Verwendung einer zus"atzlichen Variable $y$ in LOOP ausgedr"uckt
werden:
\begin{algorithmic}[1]
\STATE $y=1${\tt ;}
\STATE {\tt LOOP }$x${\tt\ DO }$y$ {\tt :=} $0$ {\tt END;}
\STATE {\tt LOOP }$y${\tt\ DO }$P$ {\tt END;}
\end{algorithmic}
Nat"urlich wird die {\tt LOOP}-Anweisung in Zeile 2 meistens viel "ofter
als n"otig ausgef"uhrt, aber es stehen hier ja auch nicht Fragen
der Effizienz sonder der prinzipiellen Machbarkeit zur Diskussion.

\subsubsection{LOOP ist nicht Turing-vollst"andig}
\begin{satz}
LOOP-Programme terminieren immer.
\end{satz}

\begin{proof}[Beweis]
Der Beweis kann mit Induktion "uber die Schachtelungstiefe
von {\tt LOOP}-Anweisungen gef"uhrt werden. Die LOOP-Programme
ohne {\tt LOOP}-Anweisung, also die Programme mit Schachtelungstiefe
$0$ terminieren offensichtlich immer. Ebenso die LOOP-Programme
mit Schachtelungstiefe $1$, da die Anzahl der Schleifendurchl"aufe
bereits zu Beginn der Schleife festliegt.

Nehmen wir jetzt an wir w"ussten bereits, dass jedes LOOP-Programm mit
Schachtelungstiefe $n$ der {\tt LOOP}-Anweisungen immer terminiert.
Ein LOOP-Programm mit Schachtelungstiefe $n+1$ ist dann eine
Abfolge von Teilprogrammen mit Schachtelungstiefe $n$, die nach
Voraussetzung alle terminieren, und {\tt LOOP}-Anweisungen der
Form
\begin{algorithmic}
\STATE{\tt LOOP }$x_i${\tt\ DO }$P${\tt\ END}
\end{algorithmic}
wobei $P$ ein LOOP-Programm mit Schachtelungstiefe $n$ ist, das also
ebenfalls immer terminiert. $P$ wird genau so oft ausgef"uhrt, wie
$x_i$ zu Beginn angibt. Die Laufzeit von $P$ kann dabei jedesmal
anders sein, $P$ wird aber auf jeden Fall terminieren. Damit ist
gezeigt, dass auch alle LOOP-Programme mit Schachtelungstiefe $n+1$
terminieren.
\end{proof}

\begin{satz}
LOOP ist nicht Turing vollst"andig.
\end{satz}

\begin{proof}[Beweis]
Es gibt Turing-Maschinen, die nicht terminieren. G"abe es einen
Turing-Maschinen-Simulator in LOOP, d"urfte dieser bei der
Simulation einer solchen Turing-Maschine nicht terminieren, im
Widerspruch zur Tatsache, dass LOOP-Programme immer terminieren.
Also kann es keinen Turing-Maschinen-Simulator in LOOP geben.
\end{proof}

\subsection{WHILE}
\index{WHILE}
WHILE-Programme k"onnen zus"atzlich zur {\tt LOOP}-Anweisung
eine {\tt WHILE}-Anweisung der Form
\begin{algorithmic}
\STATE{\tt WHILE }$x_i>0${\tt\ DO }$P${\tt\ END}
\end{algorithmic}
Dadurch ist die {\tt LOOP}-Anweisung nicht mehr unbedingt
notwendig, denn
\begin{algorithmic}
\STATE{\tt LOOP }$x${\tt\ DO }$P${\tt\ END}
\end{algorithmic}
kann durch
\begin{algorithmic}
\STATE$y:= x$;
\STATE{\tt WHILE }$y>0${\tt\ DO }$P$; $y:=y-1${\tt\ END}
\end{algorithmic}
nachgebildet werden.

\subsection{GOTO}
\index{GOTO}
GOTO-Programme bestehen aus einer markierten Folge von Anweisungen
\begin{center}
\begin{tabular}{rl}
$M_1$:&$A_1$\\
$M_2$:&$A_2$\\
$M_3$:&$A_3$\\
$\dots$:&$\dots$\\
$M_k$:&$A_k$
\end{tabular}
\end{center}
Zu den bereits bekannten Anweisungen kommt bei GOTO eine bedingte
Sprunganweisung
\begin{center}
\begin{tabular}{rl}
$M_l$:&{\tt IF\ }$x_i=c${\tt\ THEN GOTO\ }$M_j$
\end{tabular}
\end{center}
Nat"urlich l"asst sich damit auch eine unbedingt Sprunganweisung
implementieren:
\begin{center}
\begin{tabular}{rl}
$M_l$:&$x_i=c$;\\
$M_{l+1}$:&{\tt IF\ }$x_i=c${\tt\ THEN GOTO\ }$M_j$
\end{tabular}
\end{center}
In "ahnlicher Weise lassen sich auch andere bedingte Anweisungen
konstruieren, zum Beispiel ein
Konstrukt {\tt IF }\dots{\tt\ THEN }\dots{\tt\ ELSE }\dots{\tt\ END}, welches
einen ganzen Anweisungsblock enthalten kann.

\subsection{"Aquivalenz von WHILE und GOTO}
Die Verwendung eines Sprungbefehles wie GOTO ist in der modernen
Softwareentwicklung verp"ont. Sie f"uhre leichter zu Spaghetti-Code,
der kaum mehr wartbar ist. Gewisse Sprachen verbannen daher
GOTO vollst"andig aus ihrer Syntax, und propagieren dagegen
die Verwendung von `strukturierten' Kontrollstrukturen wie
WHILE. Die Aufregung ist allerdings unn"otig: GOTO und WHILE sind "aquivalent.


\begin{satz}
Eine Funktion ist genau dann mit einem GOTO-Programm berechenbar,
wenn sie mit einem WHILE-Programm berechenbar ist.
\end{satz}
\begin{proof}[Beweis]
Man braucht nur zu zeigen, dass man ein WHILE-Programm in ein "aquivalentes
GOTO-Programm "ubersetzen kann, und umgekehrt.

Um eine GOTO-Programm zu "ubersetzen, verwenden wir eine zus"atzliche Variable
$z$, die die Funktion des Programm-Z"ahlers "ubernimmt.
Aus dem GOTO-Programm machen wir dann folgendes WHILE-Programm
\begin{algorithmic}
\STATE $z:=1$
\STATE{\tt WHILE\ }$z>0${\tt\ DO}
\STATE{\tt IF\ }$z=1${\tt\ THEN\ }$A_1'${\tt\ END};
\STATE{\tt IF\ }$z=2${\tt\ THEN\ }$A_2'${\tt\ END};
\STATE{\tt IF\ }$z=3${\tt\ THEN\ }$A_3'${\tt\ END};
\STATE\dots
\STATE{\tt IF\ }$z=k${\tt\ THEN\ }$A_k'${\tt\ END};
\STATE{\tt IF\ }$z=k+1${\tt\ THEN\ }$z:=0${\tt\ END};
\STATE{\tt END}
\end{algorithmic}
Die Anweisung $A_i'$ entsteht aus der Anweisung $A_i$ nach folgenden
Regeln
\begin{itemize}
\item Falls $A_i$ eine Zuweisung ist, wird ihr eine weitere Zuweisung
\begin{algorithmic}
\STATE $z:=z+1$
\end{algorithmic}
angeh"angt. Dies hat zur Folge, dass nach $A_k'$ als n"achste Anweisung
$A_{k+1}$ ausgef"uhrt wird.
\item
Falls $A_i$ eine bedingte Sprunganweisung
\begin{center}
\begin{tabular}{rl}
$M_l$:&{\tt IF\ }$x_i=c${\tt\ THEN GOTO\ }$M_j$
\end{tabular}
\end{center}
ist, wird $A_i'$
\begin{algorithmic}
\STATE{\tt IF\ }$x_i=c${\tt\ THEN\ }$z:=j${\tt\ ELSE }$z=z+1$;
\end{algorithmic}
Dies ist zwar keine WHILE-Anweisung, aber es wurde bereits
fr"uher gezeigt, wie man sie in WHILE "ubersetzen kann.
\end{itemize}
Damit ist gezeigt, dass ein GOTO-Programm in ein "aquivalentes WHILE-Programm
mit genau einer WHILE-Schleife "ubersetzt werden kann.

Umgekehrt zeigen wir, dass jede WHILE-Schleife mit Hilfe von GOTO
implementiert werden kann. Dazu "ubersetzt man jede WHILE-Schleife
der Form
\begin{algorithmic}
\STATE{\tt WHILE\ }$x_i>0${\tt\ DO }$P${\tt\ END}
\end{algorithmic}
in ein GOTO-Programm-Segment der Form
\begin{algorithmic}[1]
\STATE{\tt IF\ }$x_i=0${\tt\ THEN GOTO }4
\STATE$P$
\STATE{\tt GOTO\ }1
\STATE
\end{algorithmic}
wobei die Zeilennummern durch geeignete Marken ersetzt werden m"ussen.
Damit haben wir einen Algorithmus spezifiziert, der WHILE-Programme in
GOTO-Programme "ubersetzen kann.
\end{proof}

\subsection{Turing-Vollst"andigkeit von WHILE und GOTO}
Da WHILE und GOTO "aquivalent sind, braucht die Turing-Vollst"andigkeit
nur f"ur eine der Sprachen gezeigt zu werden.
Wir skizzieren, wie man eine Turing-Maschine in ein GOTO-Programm
"ubersetzen kann. Dies gen"ugt, da man nur die universelle
Turing-Maschine zu "ubersetzen braucht, um damit jede andere
Turing-Maschine ausf"uhren zu k"onnen.

\subsubsection{Alphabet, Zust"ande und Band}
Die Zeichen des Bandalphabetes werden durch nat"urliche Zahlen
dargestellt.  Wir nehmen an, dass das Bandalphabet $k$ verschiedene Zeichen
umfasst. Das Leerzeichen $\text{\textvisiblespace}$ wird durch die Zahl $0$
dargestellt.

Auch die Zust"ande der Turing-Maschine werden durch nat"urliche Zahlen
dargestellt,
die Variable $s$ dient dazu, den aktuellen Zustand zu
speichern.

Der Inhalt des Bandes kann durch eine einzige Variable $b$ dargestellt
werden. Schreibt man die Zahl im System zur Basis $k$, k"onnen die
die Zeichen in den einzelnen Felder des Bandes als die Ziffern
der Zahl $b$ interpretiert werden.

Die Kopfposition wird durch eine Zahl $h$ dargestellt. Befindet sich
der Kopf im Feld mit der Nummer $i$, wird $h$ auf den Wert $k^i$
gesetzt.

\subsubsection{Arithmetik}
Alle Komponenten der Turing-Maschine werden mit nat"urlichen Zahlen
und arithmetischen Operationen dargestellt.
Zwar beherrscht LOOP nur die Addition oder Subtraktion einer Konstanten,
aber durch wiederholte Addition einer $1$ kann damit jede beliebige
Addition oder Subtraktion implementiert werden.

Ebenso k"onnen Multiplikation und Division auf wiederholte Addition
zur"uckgef"uhrt werden.
Im Folgenden nehmen wir daher an, dass die arithmetischen Operationen
zur Verf"ugung stehen.

\subsubsection{Lesen eines Feldes}
Um den Inhalt eines Feldes zu lesen, muss die Stelle von $b$ an der
aktuellen Kopfposition ermittelt werden.
Dies kann durch die Rechnung
\begin{equation}
z=b / h \mod k
\label{getchar}
\end{equation}
ermittelt werden, wobei $/$ f"ur eine ganzzahlige Division steht.
Beide Operationen k"onnen mit einem GOTO-Programm ermittelt werden.

\subsubsection{L"oschen eines Feldes}
Das Feld an der Kopfposition kann wie folgt gel"oscht werden.
Zun"achst ermittelt man mit (\ref{getchar}) den aktuellen Feldinhalt.
Dann berechnet man
\begin{equation}
b' = b - z\cdot h.
\label{clearchar}
\end{equation}
$b'$ enth"alt an der Stelle der Kopfposition ein $0$.

\subsubsection{Schreiben eines Feldes}
Soll das Feld an der Kopfposition mit dem Zeichen $x$ "uberschrieben
werden, wird mit (\ref{clearchar}) zuerst das Feld gel"oscht.
Anschliessend wird das Feld durch
\[
b'=b+x\cdot h
\]
neu gesetzt.

\subsubsection{Kopfbewegung}
Die Kopfposition wird durch die Zahl $h$ dargestellt.
Da $h$ immer eine Potenz von $k$ ist, und die Nummer des Feldes der
Exponent ist, brauchen wir nur Operationen, die den Exponenten
"andern, also
\[
h'=h/k\qquad\text{bzw.}\qquad h'=h\cdot k
\]

\subsubsection{"Ubergangsfunktion}
Die "Ubergangsfunktion
\[
\delta\colon Q\times \Gamma\to Q\times \Gamma\times\{1, 2\}
\]
ermittelt aus aktuellem Zustand $s$ und
aktuellem Zeichen $z$ den neuen Zustand, das neue Zeichen auf
dem Band und die Kopfbewegung ermittelt. Im Gegensatz zur fr"uheren
Definition verwenden wir jetzt die Zahlen $1$ und $2$ f"ur die
Kopfbewegung L bzw.~R.
Wir schreiben $\delta_i$ f"ur die $i$-te Komponente von $\delta$.
Der folgende GOTO-Pseudocode
beschreibt also ein Programm, welches die Turing-Maschine implementiert
\begin{algorithmic}[1]
\STATE Bestimme das Zeichen $z$ unter der aktuellen Kopfposition $h$
\STATE L"osche das aktuelle Zeichen auf dem Band
\STATE {\tt IF\ }$s=0${\tt\ THEN}
\STATE {\tt \ \ \ \ IF\ }$z=0${\tt\ THEN}
\STATE {\tt \ \ \ \ \ \ \ \ }$s:=\delta_1(0,0)$
\STATE {\tt \ \ \ \ \ \ \ \ }$z:=\delta_2(0,0)$
\STATE {\tt \ \ \ \ \ \ \ \ }$m:=\delta_3(0,0)$
\STATE {\tt \ \ \ \ END}
\STATE {\tt END}
\STATE {\tt IF\ }$s=1${\tt\ THEN}
\STATE {\tt \ \ \ \ }\dots
\STATE {\tt END}
\STATE Zeichen $z$ schreiben
\STATE {\tt IF\ }$m=1${\tt\ THEN }$h:=h/k$
\STATE {\tt IF\ }$m=2${\tt\ THEN }$h:=h\cdot k$
\STATE \dots
\STATE {\tt GOTO\ }1
\end{algorithmic}
Damit ist gezeigt, dass eine gegebene Turingmaschine in ein
GOTO-Programm "ubersetzt werden kann. "Ubersetzt man die universelle
Turing-Maschine, erh"alt man ein GOTO-Programm, welches jede beliebige
Turing-Maschine simulieren kann. Somit ist GOTO und damit auch WHILE
Turing-vollst"andig.

\subsection{Esoterische Programmiersprachen}
\index{Programmiersprache!esoterische}
Zur Illustration der Tatsache, dass eine sehr primitive Sprache
ausreichen kann, um Turing-Vollst"andigkeit zu erreichen, wurden
verschiedene esoterische Programmiersprachen erfunden.
Ihre N"utzlichkeit liegt darin, ein bestimmtest Konzept der Theorie
m"oglichst klar hervorzuheben, die Verwendbarkeit f"ur irgend einen
praktischen Zweck ist nicht notwendig, und manchmal explizit unerw"unscht.

\subsubsection{Brainfuck}
\index{Brainfuck}
Brainfuck
wurde von Urban M"uller 1993 entwickelt mit dem Ziel, dass der
Compiler f"ur diese Sprache m"oglichst klein sein sollte. In der
Tat ist der kleinste Brainfuck-Compiler f"ur Linux nur 171 Bytes
lang.

Brainfuck basiert auf einem einzelnen Pointer {\tt ptr}, welcher
im Programm inkrementiert oder dekrementiert werden kann.
Jeder Pointer-Wert zeigt auf eine Zelle, deren Inhalt inkrementiert
oder dekrementiert werden kann.
Dies erinnert an die Position des Kopfes einer Turing-Maschine.
Zwei Instruktionen f"ur Eingabe und Ausgabe eines Zeichens
an der Pointer-Position erm"oglichen Datenein- und -ausgabe.
Als einzige Kontrollstruktur steht WHILE zur Verf"ugung. Damit
die Sprache von einem minimalisitischen Compiler kompiliert
werden kann, wird jede Anweisung durch ein einziges Zeichen
dargestellt. Die Befehle sind in der folgenden Tabelle
zusammen mit ihrem C-"Aquivalent zusammengstellt:
\begin{center}
\begin{tabular}{|c|l|}
\hline
Brainfuck&C-"Aquivalent\\
\hline
{\tt >}&\verb/++ptr;/\\
{\tt <}&\verb/--ptr;/\\
{\tt +}&\verb/++*ptr;/\\
{\tt -}&\verb/--*ptr;/\\
{\tt .}&\verb/putchar(*ptr);/\\
{\tt ,}&\verb/*ptr = getchar();/\\
{\tt [}&\verb/while (*ptr) {/\\
{\tt ]}&\verb/}/\\
\hline
\end{tabular}
\end{center}
Mit Hilfe des Pointers lassen sich offenbar beliebige Speicherzellen
adressieren, und diese k"onnen durch Wiederholung der Befehle {\tt +}
und {\tt -} auch um konstante Werte vergr"ossert
oder verkleinert werden. Etwas mehr Arbeit erfordert die Zuweisung
eines Wertes zu einer Variablen. Ist dies jedoch geschafft, kann
man WHILE in Brainfuck "ubersetzen, und hat damit gezeigt, dass
Brainfuck Turing-vollst"andig ist.

\subsubsection{Ook}
\index{Ook}
Die Sprache Ook verwendet als syntaktische Element das Wort {\tt Ook} gefolgt
von `{\tt .}', `{\tt !}' oder `{\tt ?}'. Wer beim Lesen eines Ook-Programmes
den Eindruck hat, zum Affen gemacht zu werden, liegt nicht ganz falsch:
Ook ist eine einfach Umcodierung von Brainfuck:
\begin{center}
\begin{tabular}{|c|c|}
\hline
Ook&Brainfuck\\
\hline
{\tt Ook. Ook.}&{\tt +}\\
{\tt Ook! Ook!}&{\tt -}\\
{\tt Ook. Ook?}&{\tt >}\\
{\tt Ook? Ook.}&{\tt <}\\
{\tt Ook! Ook?}&{\tt [}\\
{\tt Ook? Ook!}&{\tt ]}\\
{\tt Ook! Ook.}&{\tt .}\\
{\tt Ook. Ook!}&{\tt ,}\\
\hline
\end{tabular}
\end{center}
Da Brainfuck Turing-vollst"andig ist, ist auch Ook Turing-vollst"andig.
